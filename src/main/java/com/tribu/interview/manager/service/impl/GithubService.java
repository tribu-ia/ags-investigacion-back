package com.tribu.interview.manager.service.impl;

import com.tribu.interview.manager.dto.GithubUserResponse;
import com.tribu.interview.manager.service.IGithubService;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpMethod;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.kohsuke.github.GHContentBuilder;
import org.kohsuke.github.GHRepository;
import org.kohsuke.github.GitHub;
import org.kohsuke.github.GitHubBuilder;
import org.kohsuke.github.GHRef;
import org.kohsuke.github.GHPullRequest;

import java.io.IOException;
import java.util.List;
import java.util.Optional;

@Slf4j
@Service
@RequiredArgsConstructor
public class GithubService implements IGithubService {
    private final RestTemplate restTemplate;
    
    @Value("${github.api.token}")
    private String githubToken;
    
    @Value("${github.repository.owner}")
    private String repositoryOwner;
    
    @Value("${github.repository.name}")
    private String repositoryName;

    private GitHub github;
    
    @PostConstruct
    public void init() throws IOException {
        github = new GitHubBuilder()
            .withOAuthToken(githubToken)
            .build();
    }

    @Override
    public Optional<GithubUserResponse> fetchUserData(String username) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("Authorization", "token " + githubToken);
            headers.set("Accept", "application/vnd.github+json");
            headers.set("X-GitHub-Api-Version", "2022-11-28");
            
            HttpEntity<String> entity = new HttpEntity<>(headers);
            
            var response = restTemplate.exchange(
                "https://api.github.com/users/" + username,
                HttpMethod.GET,
                entity,
                GithubUserResponse.class
            );
            
            return Optional.ofNullable(response.getBody());
        } catch (Exception e) {
            log.error("Error fetching GitHub data for user {}: {}", username, e.getMessage());
            return Optional.empty();
        }
    }

    public String uploadDocumentation(
            String folderPath, 
            String documentName,
            String markdownContent,
            String researcherName,
            List<MultipartFile> documents) {
        try {
            String formattedResearcherName = sanitizeFileName(researcherName);
            String completeFolderPath = folderPath + "/" + formattedResearcherName;
            
            // Crear nombre de la rama
            String branchName = "documentacion/" + completeFolderPath;
            
            GHRepository repository = github.getRepository(repositoryOwner + "/" + repositoryName);
            
            // Obtener la referencia del Ãºltimo commit en main
            GHRef mainRef = repository.getRef("heads/main");
            String mainSha = mainRef.getObject().getSha();
            
            // Crear nueva rama desde main
            try {
                repository.createRef("refs/heads/" + branchName, mainSha);
            } catch (IOException e) {
                log.warn("Branch might already exist: {}", e.getMessage());
            }
            
            // Subir el archivo markdown principal
            repository.createContent()
                     .branch(branchName)
                     .path(completeFolderPath + "/" + documentName)
                     .content(markdownContent)
                     .message("Add main documentation file")
                     .commit();
            
            // Subir cada documento adjunto
            for (MultipartFile document : documents) {
                String fileName = sanitizeFileName(document.getOriginalFilename());
                repository.createContent()
                         .branch(branchName)
                         .path(completeFolderPath + "/" + fileName)
                         .content(document.getBytes())
                         .message("Add supporting document: " + fileName)
                         .commit();
                
                log.info("Adding file to commit: {}", fileName);
            }
            
            // Crear Pull Request
            String prTitle = "Documentation for " + completeFolderPath;
            String prBody = String.format("Generated by research agent for %s\n\nThis PR includes:\n" +
                                        "- Main documentation file\n" +
                                        "- %d supporting documents", 
                                        researcherName, documents.size());
            
            GHPullRequest pullRequest = repository.createPullRequest(
                prTitle,
                branchName,
                "main",
                prBody
            );
            
            log.info("Successfully uploaded {} files to {} and created PR #{}",
                documents.size() + 1, completeFolderPath, pullRequest.getNumber());
            
            // Retornar la URL del Pull Request en lugar de la carpeta
            return pullRequest.getHtmlUrl().toString();
                
        } catch (Exception e) {
            log.error("Error uploading to GitHub: {}", e.getMessage(), e);
            throw new RuntimeException("Failed to upload documentation to GitHub", e);
        }
    }
    
    private String sanitizeFileName(String fileName) {
        if (fileName == null) return "document.txt";
        return fileName.trim()
            .toLowerCase()
            .replaceAll("[^a-z0-9.-]", "-")
            .replaceAll("-+", "-");
    }
} 